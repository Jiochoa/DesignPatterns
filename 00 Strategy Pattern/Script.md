```toc
```

## Intro
Hello and welcome to this tutorial series on Software Design Patterns. In this video we will learn the Strategy Design Pattern, with examples and descriptions provided mainly by the Head First Design Pattern Book. So, let's get started.

## Scenario
This will be our scenario. Imagine you work at a (--)Duck simulation company, but the market is becoming more and more competitive. So, your boss wants you innovate and add new behaviors to the ducks, he wants you to make them fly(--). But first, (--) lets look at the current system. It has a superclass called Duck (--) right now all they can do quack, swim and a (--)display themselves. Notice that the (--)display function is abstract because all ducks look different, therefore they each have to implement their display function themselves.. All the specific ducks are in the subclasses (--) right here we have Mallard ducks and Readhead ducks but there is a lot more than that.

And that, is the sum of our current system. A bunch of subclasses to represent all of the ducks and a superclass with shared behaviors. Now let see what we can do about making them fly.

## Uneducated Solution
### Solution 1
The solution seems simple enough, why not use (-1-)inheritance. So, we take the (-2-) superclass and give it the method to fly (-3-) that way all the subclasses will inherit it and be able to fly as well. There’s a problem with this. If we take a closer inspection, we’ll notice that among all the ducks there are a few that are fake, like this rubber duck(-4-), and fake ducks shouldn’t be able to fly. Keep in mind that this can be fixed (-5-) by simply overwriting the fly method in the rubber duck into an empty function since they cant fly, but If we continue this path not only would we have to overrider the rubber duck but every single class that has any type of fake ducks. Including ducks that might be added in the future. (-6-)Let’s try something else.

### Solution 2
What about interfaces. (--) We can make a Flyable and a Quackable (--)interface and give it to every subclass that needs them(--), let’s look at the code of the Mallard Duck(--) it implements both the Quackable and flyable behavior because it can do both. Then there’s other ducks (--) like the Rubber Duck who cant fly but can quack, which is more like a squeak. So it would only have to implement one interface the, Quackable interface.

We have another problem here. Not only did we give ourselves a lot of work with having to change almost every class in the system but also, we’re going to have a lot of repeated code (--)mainly because a lot of the ducks fly the same way and quack the same way.(--) So we’re going to need another solution. Let’s start talking about the Strategy Design Patterns

## Formal DP
The formal definition is The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it. Let’s take it bit by bit. We have the (--)Context ,which could be anything, a Duck class for example, but it could be any class, so we’ll keep it general. First, let’s look at the phrase (--)“define a family of algorithms”, what does this mean. Behaviors that accomplish similar things can be grouped into a family. We know all about sorting algorithms, QuickSort, BubbleSort, or MergeSort (--)they are all completely different things, but they accomplish essentially the same thing, which is to return a sorted list. We could call them a (--)family of algorithms. Now that we know what they are, we just need to “define” these “families of algorithm” in our system. To do that we apply our first (--)Design Principle, Identify the aspects of your application that vary and separate them from what stays the same. In other words, we inspect our context looking for things that might change in the future and then we pull them out. (--) The goal of this Design Pronciple is to isolate (--)these parts so we can change them freely without jeopardizing the rest of the system. We continue with the definition, (--) “encapsulates each one and make them interchangeable” and how do we do that?. We once again, invoke out design principles, (--)Program to an interface not an implementation. The word “interface” here is overloaded. What they mean is to take advantage of polymorphism. In other words, we could use either an abstract class or an interface, as long as we use a supertype so that the code is not locked into a specific thing. (--)To apply it, we’re going to use an interface and we end up with this (--), we can move on with the definition. (--) “Strategy lets the algorithm vary independently from clients that use it” which we already accomplished, the context can (--)pick and choose which concrete strategy to use at runtime depending on their needs. So, we could have many different clients calling the same supertype and doing entirely different things, as long as they are part of the family of algorithms.

## Solve the Problem with the DP
Now that we have a better understanding of the Strategy Pattern, let’s apply it to our problem. On this scenario, our context is going to be the (--) Duck class, now let’s try to define the family of algorithms. Even though ducks might look very similar(--), they are actually very different. Some of them can fly (--) and other cannot, and even among those that can fly (--) some of them can only fly for a very short distances while other are excellent flyers. Another thing to consider is the sound they make.  Even though most of them can quack they all do it in a different way.  (--) Some of them do long quacks, others short quacks, others make noises that don’t even sound like a quack. Not to mention fake ducks who can’t fly or quack but squeak instead.

We have successfully identified two families of algorithms, (--) the behavior of flying and the behavior of quacking, so let’s implement them. We extract the fly and quack behaviors and give them a supertype (--) let’s call them FlyBehavior and QuackBehavior, Then we go to the Duck class and make two methods to call these behaviors, (--) performFly and performQuack, and of course, let’s not forget the setters. Now let’s make the concrete strategies for the FlyBehavior, there’s are too many to cover them all but two examples would be the (--) average flying duck, lets call it FlyWithWings, and another for duck that cant fly like for fake ducks, let’s call it FlyNoWay. As for the QuackBehaviors, two examples would be a (--) regular quack for the average duck, and another would be a squeak for rubber ducks and other fake ducks. And lastly, we bring in our specific ducks. (--) And that is the sum of our system in diagram form, now we can start implementing it in the code.

## Demo
### Flight Behavior
Let’s start with the FlyBehavior since it’s very straightforward. We make the interface and give it only one function, fly. This will ensure that all subclasses have this function. (-1-) Then we move on to our individual strategies. Starting with FlyWithWings, first we implement the interface we just made, then we overwrite the fly function into whatever we want it to be, for now, a print statement is sufficient enough. (-2-) And last, there's the FlyNoWay which is for fake ducks. Again, we’ll implement the FlyBehavior as the previous one and then we overwrite the fly function. We are just printing in here but in a real simulation this could be a very complicated function full of animations and sounds.

### Quack Behavior
Next is the QuackBehaviors, This is essentially the same as the FlyBehavior. We have an interface with a single function, quack. And two concrete strategies, Quack and Squeak who overwrite their quack method into a simple print statement.

### Duck
We move to the Duck class. This is what we currently have a quack method, a swim method, a display abstract method and a fly method. And this (-1-) is what we need to do. (-2-) Let’s start by making a reference to our behaviors. Also, we don’t need the quack method anymore, so we are going to remove it. As for the swim method, we are going to keep it, but with a slight change to fit all the ducks. (-3-) We also don’t need the fly method, we are going to replace it with the performFly method .(-4-) This function is going to use the FlyBehavior variable to call one of the concrete strategies. As of now, we don’t know what it is, but it has to be one inside the family of algorithms of the FlyBehavior. (-5-) And same with the PerfromQuack since they work the same in this design. And last, we make the setter for the Fly and quack behavior, this will allow us to change this behaviors at runtime. And that’s it for the Duck class. Lets move on to the concrete ducks.

### Concrete Duck
This is what we currently have. (-1-) Starting with the Mallard Duck the only thing we are going to do here is make a constructor that is going to define the specific strategies that we want for the specific duck. In this case, a mallard duck flies with wings, so we add the FlyWithWings strategy, and it also makes a regular quack, so well need the Quack strategy. (-2-) Moving on to the Rubber duck, This is a fake duck so it doesn’t fly so we’ll need the FlyNoWay strategy. It also doesn’t quack but it does squeak, so we’ll need the Squeak strategy. The rest of the concrete duck follow a similar procedure where we define their behaviors in their constructor. So lets move on.

### Test
And that is the sum of our implementation, and Now we can test it. We start by making a Duck object called mDuck and trough polymorphism we make it into a Mallard Duck. We are going to call its display method, its performFly method and its performQuack method. (-1-) We are also going to test another duck. Same process, we make a Duck object, we’ll call it rDuck this time we make it into a Rubber Duck,  we call their display, fly, and quack functions. Then we run it (-2-) And it looks like a success. as shown in the results, We successfully called their display method from the subclass, then called their concrete strategies from the behavior variables. We just put in a lot of work on the design, let’s remind ourself why we did all of this

## Benefits
No matter where you work, what you’re building, or what language you are programming in, the one true constant that will be with you always is (--) change. If we make an (--)application and want to keep it alive for as long as possible, we are going to have a lot of changes. From adjusting it to new hardware, (*) to adding new functionality, (*) and everything in-between. So, we need to find a way to manage that. Design Patterns are the answer, and more specifically, the Strategy Pattern. With our new design, we are now able to add as many ducks as we want and as many behaviors as we want, and we don’t have to change any of the existing code. Not to mention that we can even change them at runtime!

## Outro
That’s it for this video/ Thank you for watching. If you have any questions, leave them in the comment section.

This is a a test about how