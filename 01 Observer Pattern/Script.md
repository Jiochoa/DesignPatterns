### Introduction

Hello and welcome to this tutorial series on Software Design Patterns. In this video we will learn the Observer Design Pattern, with examples and descriptions provided mainly by the Head First Design Pattern Book. So, let's get started.

### Scenario
#### Part 1
Imagine you are working at a weather company (-1-). Your boss gives you a new task (-2-), she wants you to create an app that uses the WeatherData object , (-3-) which will be provided by the company, to update the three different displays, one for current conditions, another one for weather stats, and another one for forecast.(-4-) Now, let's see what we have available. We have a Weather Station (-5-) this component talks directly with the physical sensor devices of Temperature,(-6-) Humidity, (-7-) and Pressure. (-8-) We also have the WeatherData object (-9-) who talks to the Weather Station to get the most recent values. (-10-)We will not go in depth on how it does it, for now, we just need to know that it does. With your help, this WeatherData object will be the one to update the Current Condition(-11-) display, the Weather Stats display (-12-)and the Forecast Display(-13-). Now let’s take a look at what’s inside the WeatherData object

#### Part 2
Inside of it, we have the three methods (-1-), getTemperature, getHumidity and getPressure, that will get the most recent values from the Weather Station. Also, this is where we will create a new function, (-2-) measurementsChanges(), and this is where we will accomplish the task.(-3-) As stated, the function should update the three different displays, which are not strictly part of the task but we will make them for testing purposes. And that, is the sum of our current system. So, let’s get to work.

### Uneducated Solution
Now that we have our task,(--) let’s give it a shot without any patterns.(--) First we need to make the method inside the WeatherData (--). As stated, we are going to call it measurmentsChanges.(--) Then we need to get the most recent values of temperature, humidity, and pressure. Again, we are not concern about how they work, we just need to know that they come from the Weather Station.  We can go on and start updating the displays. We also don’t have the actual displays right now but again, they're not important right now, we're just focusing on the measurmentsChanges function. So we started with the CurrentConditionDisplay (--)and we give it the most recent values for the update. Then we continue on with the StatisticsDisplay(--) and again we give it the necessary values to update. Lastly, we go to the ForecastDisplay (--)and we do the same and give it what it needs to update.

Now that we have a finished product lets analyze our program.

It doesn’t look too bad, (*) we accomplished out task after all but there are a few things wrong with this implementation, lets go over them. First of all, we hardcoded the answer(*) therefore we cannot add or remove new displays without going back to the code which is not good for new developers, we need to add some flexibility to it. A good fix would be to encapsulate it, since they are the most likely to change. All three displays are using the same update method, so we did do a few things right, although not entirely correct because what if in the future we add a new sensor to the Weather station, wind speed for example.  Our system wouldn’t be able to handle that, so we need another fix for that too. Let’s talk a little about the Observer Pattern.

### Formal Pattern

The Observer Pattern is (*) Defined as a one-to-many dependency between objects so that when one object changes, all of its dependents are notified and updated automatically. Before we dissect the definition, let’s try to see the big picture with a real-world example.

Let’s talk about the stock market. (*) The stocks go up and down and up again, and there's is a lot of money involved so every single change matters, especially to its traders.(*) They are the “dependents“ (*) of the stock market, this is a “one-to-many” relationship because many clients used the Stock Market system. So, it’s very important (*) for them to be automatically notified of every single change (*) because they could be losing(*) a lot of money (*) for every minute they keep a hold of a stock that is dropping rapidly, (*) as well as they could make a lot of money (*) by selling stock on high demand. (*) Time is very important in this equation. In this system, we could see the Observer Pattern.

### Solve the Problem with the DP

Now lets try solving the problem with the observer pattern. First we make the Subject and Observer interfaces. In this instance, the WeatherData is going to be the subject since it’s the one that should notify the Displays objects every time something changes. Now, we implement our Displays. First the CurrentConditionsDisplay, which will implement the Observer interface, we don’t need to know how they will use the information all we need to know is that there's an update method. Same with the StatisticsDisplay and the ForecastDisplay. Lets also add a DisplayElement interface for testing purposes that will only have one method, display(), they just need to have the observer interface and they can be registerd to the subject.

### Do the task with poor design

Now that we have our task,(*) let’s give it a shot.(*) First we need to make the method inside the WeatherData (*). As stated, we are going to call it measurmentsChanges.(*) Then we need to get the most recent values of temperature, humidity, and pressure. Again, we are not concern about how they work, we just need to know that they come from the Weather Station.  We can go on and start updating the displays. We also don’t have the actual displays right now but again, they're not important right now, we're just focusing on the measurmentsChanges function. So we started with the CurrentConditionDisplay and we give it the most recent values for the update. Then we continue on with the StatisticsDisplay, and again we give it the necessary values to update. Lastly, we go to the ForecastDisplay and we do the same and give it what it needs to update.

Now that we have a finished product, let's see what we did right and what we did wrong

### Add the Observer pattern to fix the design

## Demo 

We will begin by implementing the interfaces. Let's start with the Observer. It's pretty simple since it only has one method, `update ()`. With it, it will update the displays with the new information, every display is different, so we're not worried right now about how the Display classes will use it. We move on to the Subject interface. This one has 3 methods, `registerObserver()` which will add a display to the list so the Subject can send them updates, `removeObserver()`, which will remove the selected observer, and `notifyObservers()` which will make sure every observer knows there was a change in the subject. And Lastly, we make the `DisplayElement` interface which will one have one method, `display()` that ensures the displays can show their change. We move on to the `WeatherData` class which will implement the Subject interface. We're going to keep a list of the observers in a `List` to have a record of every active observer. We will initiate this `List` in the constructor. Since we're using a `List` adding and deleting is very simple we just `add()` and `remove()`. For `notifyObserver()` we will iterate all the observers from the list and call their `update()` method which all observers will have because of the Observer interface. We will call this method in the `measurementChanges()`. Lastly, we need to set the measurements to their most recent value, we will do that with `setMearuements()`, in here we will also call the `measurementChanges()` method which will notify all the observers about this change.Moving on to the displays, we'll start with the `CurrentConditionDisplay`, this one will implement the Observer and the `DisplayElement` interfaces. We will keep a copy of the weather data, so we can call its add/remove methods. The `update()` will get the current values which will be used on the `display()`. The rest of the Displays are exactly the same, with the exception that they might use only some of the data available. Not all display need to know the pressure, for example.Now that we have everything ready, let's test our code. We start by making a `WeatherData` object which will communicate with the Weather Station. From there, we can start making the displays, which will automatically register with the given `weatherStation`. Then we give it some random measurements to test it. Let's try that again and run it and see what it gives us. We didn't went trough the specifics of the displays but we can see that it's printing 6 things, and thats because we gave it 2 diferent values and it prints all 3 displays every time theres a change.

## Benefits

Alight, We just made a bunch of changes, we wrote about double the amount of code as our first solution, so it doesn’t seem too productive. But why? It goes back to the first thing we learned about programming, that code will always change over time. The more successful the program the more changes are to be expected.  So we need to prepare for them. Without noticing, we started using another Design Principle that is innate to the Observer Pattern. (*) Stive for loosely coupled designs between objects that interact. The only thing the Subject should know about the observer is that (*)it implements the Observer interface and with it, the update() method. Also, we can add new observers at any time because the only thing the subject depends on is in the observers interface so it gives us a lot of freedom on what to do with either the subject or the observers. Another example is that we can reuse the subject and observer, for example by adding another interface without affecting its functionality since they are not tightly coupled.




